# 作用域和闭包



## 什么是作用域

**作用域**，关于 **变量如何存储** 以及 **如何找到这些变量** 的一组明确定义的 **规则**。

> 编译器理论  
> JS 的 **编译** 发生在代码执行前  
> 简单概括编译: 1.将源代码字符串分词（token 记号）; 2.解析 token，将其转化为 **AST 抽象语法树**;3.转换为可执行的代码

变量的查询分为 **LHS** 和 **RHS**

- LHS，为了向变量赋值。发生在 = 等号赋值和参数传递。未被满足时，在全局作用域创建一个同名变量（非严格模式），或者 ReferenceError （严格模式）。
- RHS，为了取得变量的值。未被满足时， ReferenceError。找到变量，但执行了非法操作，如引用 null/undefined 的属性或者将非函数变量当作函数执行， TypeError。

**作用域的嵌套**，作用域可以嵌套在另一个作用域中。

> LHS 和 RHS 都是从当前执行中的 **作用域** 开始，如果有需要，会层层向上查询，直到全局作用域

```
JS 引擎 在执行代码之前首先会编译它，因此，它将 var a = 2; 这样的语句分割为两个分离的步骤：
1. 遇到 var a，编译器 让 作用域 去查看对于这个特定的作用域集合，变量 a 是否已经存在了。如果是，编译器 就忽略这个声明并继续前进。否则，编译器 就让 作用域 去为这个作用域集合声明一个称为 a 的新变量。
2. 然后 编译器 为 引擎 生成稍后要执行的代码，来处理赋值 a = 2。引擎 运行的代码首先让 作用域 去查看在当前的作用域集合中是否有一个称为 a 的变量可以访问。如果有，引擎 就使用这个变量。如果没有，引擎 就向 上层作用域 查找。
```

## 词法作用域

> 词法作用域是基于，在写程序时，变量和作用域的块儿在何处被编写决定的，因此它在词法分析器处理代码时（基本上）是固定不变的。

```js
function foo(a) {
  var b = a * 2;

  function bar(c) {
    console.log(a, b, c);
  }

  bar(b * 3);
}

foo(2); // 2 4 12
```

在上面的代码段中，引擎 执行语句 console.log(..) 并开始查找三个被引用的变量 a，b 和 c。它首先从最内部的作用域气泡开始，也就是 bar(..) 函数的作用域。在这里它找不到 a，所以它向上走一层，到外面下一个最近的作用域气泡，foo(..) 的作用域。它在这里找到了 a，于是它就使用这个 a。同样的事情也发生在 b 身上。但是对于 c，它在 bar(..) 内部就找到了。

如果在 bar(..) 内部和 foo(..) 内部都有一个 c，那么 console.log(..) 语句将会找到并使用 bar(..) 中的那一个，绝不会到达 foo(..) 中的那一个。

一旦找到第一个匹配，作用域查询就停止了。相同的标识符名称可以在嵌套作用域的多个层中被指定，这称为“遮蔽（shadowing）”（内部的标识符“遮蔽”了外部的标识符）。无论如何遮蔽，作用域查询总是从当前被执行的最内侧的作用域开始，向外/向上不断查找，直到第一个匹配才停止。

注意： 全局变量也自动地是全局对象（在浏览器中是 window，等等）的属性，所以不直接通过全局变量的词法名称，而通过将它作为全局对象的一个属性引用来间接地引用，是可能的。

### 欺骗词法作用域  eval 和 with

```
词法作用域意味着作用域是由编写时函数被声明的位置的决策定义的。编译器的词法分析阶段实质上可以知道所有的标识符是在哪里和如何声明的，并如此在执行期间预测它们将如何被查询。

欺骗词法作用域 压制了 引擎 在作用域查询上进行编译期优化的能力，因为 引擎 不得不悲观地假定这样的优化是无效的。这两种特性的结果就是代码 将 会运行的更慢。不要使用它们。
```

> **eval**，可以用编程的方式在编写好的代码内部生成代码，而且可以运行这个生成的代码，就好像它在编写时就已经在那里了一样。

```js
function foo(str, a) {
  eval(str); // 作弊！
  console.log(a, b);
}

var b = 2;

foo("var b = 3;", 1); // 1 3
```

> **with**，在运行时将一个对象和它的属性转换为一个带有 “标识符” 的 “作用域”。

```js
function foo(obj) {
  with (obj) {
    a = 2;
  }
}

var o1 = {
  a: 3,
};

var o2 = {
  b: 3,
};

foo(o1);
console.log(o1.a); // 2

foo(o2);
console.log(o2.a); // undefined
console.log(a); // 2 -- “作用域” o2 中没有，foo(..) 的作用域中也没有，甚至连全局作用域中都没有找到标识符 a，所以当 a = 2 被执行时，其结果就是自动全局变量被创建
```

### 动态作用域

相比词法作用域，动态作用域本身不关心函数和作用域是在哪里和如何被声明的，而是关心 **它们是从何处被调用的**。换句话说，它的作用域链条是基于调用栈的，而不是代码中作用域的嵌套。



## 函数与块级作用域

在 JavaScript 中函数是最常见的作用域单位。在另一个函数内部声明的变量和函数，实质上对任何外围“作用域”都是“隐藏的”，这是优秀软件的一个有意的设计原则。

从 ES3 开始，`try/catch` 结构在 `catch` 子句上拥有块儿作用域。

在 ES6 中，引入了 `let` `const` 关键字（`var` 关键字的表兄弟）允许在任意代码块中声明变量。`if (..) { let a = 2; }` 将会声明变量 `a`，而它实质上劫持了 `if` 的 `{ .. }` 块级作用域，并将自己附着在这里。



## 提升

我们可能被诱导而将 `var a = 2` 看作是一个语句，但是 JavaScript *引擎* 可不这么看。它将 `var a` 和 `a = 2` 看作两个分离的语句，第一个是编译期的任务，而第二个是执行时的任务。

这将导致在一个作用域内的所有声明，不论它们出现在何处，都会在代码本身被执行前 *首先* 被处理。你可以将它可视化为声明（变量与函数）被“移动”到它们各自的作用域顶部，这就是我们所说的“提升”。

声明本身会被提升，但不是赋值，即便是函数表达式的赋值，也 *不会* 被提升。

函数声明会被提升，函数表达式不会。

```js
foo();

function foo() {
	console.log( a ); // undefined

	var a = 2;
}
```

```js
foo(); // TypeError
bar(); // ReferenceError

var foo = function bar() {
	// ...
};
```

函数声明与变量声明，函数声明优先。

```js
foo(); // 1

var foo;

function foo() {
	console.log( 1 );
}

foo = function() {
	console.log( 2 );
};
```

虽然多个/重复的 `var` 声明实质上是被忽略的，但是后续的函数声明确实会覆盖前一个。

```js
foo(); // 3

function foo() {
	console.log( 1 );
}

var foo = function() {
	console.log( 2 );
};

function foo() {
	console.log( 3 );
}
```

在普通的块儿内部出现的函数声明一般会被提升至外围的作用域，而不是像这段代码暗示的那样有条件地被定义：

```js
foo(); // "b"

var a = true;
if (a) {
   function foo() { console.log( "a" ); }
}
else {
   function foo() { console.log( "b" ); }
}
```



## 闭包

**闭包就是当一个函数即使是在它的词法作用域之外被调用时，也可以记住并访问它的词法作用域。**

> 模块要求两个关键性质：1）一个被调用的外部包装函数，来创建外围作用域。2）这个包装函数的返回值必须包含至少一个内部函数的引用，这个函数才拥有包装函数内部作用域的闭包。

